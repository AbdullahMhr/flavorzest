import { PRODUCTS } from "./src/lib/data";
import * as fs from "fs";

let sql = `-- Seed file generated to migrate data.ts into Supabase\n\n`;

PRODUCTS.forEach((product) => {
    // Escape single quotes for SQL
    const name = product.name.replace(/'/g, "''");
    const description = product.description.replace(/'/g, "''");
    const origin = product.origin.replace(/'/g, "''");

    // Notes as JSONB
    const notesJson = JSON.stringify(product.notes).replace(/'/g, "''");

    // We can use random UUIDs for the products because Supabase doesn't need to match the "1", "2" strings if we don't want to.
    // However, to keep it consistent, we can just let Supabase generate them, and we use a CTE or returning clause.
    // Since we need to link variants, we can specify a UUID explicitly.
    // We will generate deterministic UUIDs based on the string ID or just random ones generated by JS in this script.

    const crypto = require('crypto');
    const productId = crypto.randomUUID();

    sql += `INSERT INTO products (id, name, price, description, image, category, gender, notes, origin, "isSignature", "order", "isHidden")\n`;
    sql += `VALUES ('${productId}', '${name}', ${product.price}, '${description}', '${product.image}', '${product.category}', '${product.gender}', '${notesJson}'::jsonb, '${origin}', ${product.isSignature}, ${product.order || 0}, ${product.isHidden || false});\n\n`;

    product.variants.forEach((v) => {
        const variantId = crypto.randomUUID();
        const size = v.size.replace(/'/g, "''");
        sql += `INSERT INTO product_variants (id, product_id, size, price, quantity)\n`;
        sql += `VALUES ('${variantId}', '${productId}', '${size}', ${v.price}, ${v.quantity});\n\n`;
    });
});

fs.writeFileSync("supabase_seed.sql", sql);
console.log("Successfully generated supabase_seed.sql!");
